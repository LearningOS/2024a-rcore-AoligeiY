# 实现功能

​		查询当前正在执行的任务信息。任务信息包括任务状态、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长。

​		为实现该功能，我将TaskInfo结构体作为TCB的字段封装起来，以便管理。任务状态信息以及系统调用及次数可以通过TCB的`task_info`（TaskInfo类型）字段进行访问，而系统调用时刻距第一次调度的时长，通过对TCB添加了额外的字段`last_time`，每次任务被调度时该数值将被更新。

​		为了获取当前任务的信息，我为任务管理模块（`TaskManager`类型）实现了一个方法`fetch_task_info`，该方法将更新当前任务的运行时间和上一次被调用时间并将返回一个TaskInfo类型。总的来说，当调用`SYSCALL_TASK_INFO`系统调用，os首先将当前任务的调用次数加一，后调用`sys_task_info`函数，而该函数将调用我实现的 `fetch_task_info`方法以获取任务信息。



# 简答作业

一、正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 [三个 bad 测例 (ch2b_bad_*.rs)](https://github.com/LearningOS/rCore-Tutorial-Test-2024A/tree/master/src/bin) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

报错：Error mapping file: Cannot allocate memory

即内存访问错误。因为程序尝试向地址 `0x0` 写入数据，这是一个无效的内存地址，通常会导致段错误。

```
[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
```



二、深入理解 [trap.S](https://github.com/LearningOS/rCore-Camp-Code-2024A/blob/ch3/os/src/trap/trap.S) 中两个函数 `__alltraps` 和 `__restore` 的作用，并回答如下问题:

1. L40：刚进入 `__restore` 时，`a0` 代表了什么值。请指出 `__restore` 的两种使用情景。

`a0`代表内核栈栈顶指针。



- 情景一： 任务切换

​	在多任务操作系统中，`__restore` 用于恢复处于Ready状态的上下文。步骤如下：

​		- 保存当前任务的上下文。

​		- 使用 `__restore` 恢复另一个任务的上下文，使其继续执行。

- 情景二：Trap处理

​	在处理Trap时，`__restore` 用于恢复被Trap中断的程序：

​		- Trap中断发生时，保存当前上下文。

​		- 进入trap中断函数处理Trap。

​		- 用 `__restore` 恢复中断前的上下文，继续执行被Trap中断的程序。



2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。

- `ld t0, 32*8(sp)` 和 `csrw sstatus, t0`。从内核栈中加载保存的 `sstatus` 寄存器值到 `t0`，然后通过 `csrw` 指令将其写回到 `sstatus` 寄存器。
  - 恢复 `sstatus` 是为了确保在返回到用户态时，CPU 能够使用正确的状态信息(特权信息)，以便任务能无缝恢复执行。



- `ld t1, 33*8(sp)` 和 `csrw sepc, t1`。这行代码从内核栈中加载保存的 `sepc` 值到 `t1`，然后将其写回 `sepc`。
  - `sepc` 寄存器保存了进入内核态之前的指令地址。
  - 恢复 `sepc` 的目的是确保在 `sret` 指令执行时，CPU 可以准确地返回到用户态任务被中断的位置，使得程序能够从上次中断的位置继续执行。



- `ld t2, 2*8(sp)` 和 `csrw sscratch, t2`。从内核栈中加载保存的用户态栈指针到 `t2`，然后将其写回到 `sscratch`。
  - `sscratch` 用于在进入内核态时暂时保存一些寄存器的值。在这里，用作保存用户态的栈指针。
  - 恢复 `sscratch` 是为了返回到用户态时，CPU 可以使用正确的栈指针。任务在用户态继续执行时，会在正确的用户态栈上进行。



3. L50-L56：为何跳过了 `x2` 和 `x4`？

-   `x2` 是栈指针寄存器 (`sp`) ，跳过该寄存器是因为恢复过程中不能直接操作栈指针，否则会影响当前栈的使用。栈指针会通过特殊指令（`csrrw sp, sscratch, sp`）正确恢复。

- `x4` 是线程指针 (`tp`)，跳过 `x4`  是因为 `tp` 通常用于线程指针，在任务切换和恢复的过程中无需更改它，因此没有必要保存和恢复。



4. L60：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

执行前，`sp` 当前指向内核栈栈顶，即处理用户态任务进入内核态时保存上下文的地方。

`sscratch` 指向的是从用户态切换到内核态时，用户任务的栈指针 。

执行后，`sp`和`sscratch`将交换值，即`sp`指向用户态栈指针，`sscratch`指向内核态栈指针。



5. `__restore`：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

- 发生状态切换的指令是`sret`，用于从 S 模式（即内核态）返回到 U 模式（即用户态）。它的作用是恢复之前保存的用户态上下文，使处理器从内核态切换回用户态。

- 在 `__restore` 函数中，已经从内核栈中恢复了之前保存的 `sstatus` 和 `sepc` 寄存器的值。

  执行 `sret` 时：

  - `sstatus` 的 `SPP` 位会被用来决定处理器特权级别。如果 `SPP = 0`，则切换到用户态。
  - `sepc` 的值会被加载到PC中，因此执行会从 `sepc` 中保存的地址继续，也就是进入内核之前的用户程序地址。



6. L13：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？

执行后，`sp` 指向内核栈栈顶，即处理用户态任务进入内核态时保存上下文的地方。

`sscratch` 指向的是从用户态切换到内核态时，用户任务的栈指针 。



7. 从 U 态进入 S 态是哪一条指令发生的？

` call trap_handler`指令发生的。



## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > 无

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > 《rCore-Camp-Guide-2024A 文档》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
