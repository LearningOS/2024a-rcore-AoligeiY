## 实现的功能

将ch3的代码移植ch4，调整了部分代码以适配作业要求。另外实现了系统调用中新增的内存管理的接口：`sys_mmap`、`sys_munmap`，其中`sys_mmap`实现mmap，`sys_munmap`实现unmap，两个都将调用在os/src/task/task.rs中实现了新函数方法。



## 问答作业



### 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？

**[53:10]这44位是物理页号，最低的8位[7:0]则是标志位。**

标志位的作用：

**V (Vaild)**：为 1 时，表示该页表项有效。如果为 0，则该页表项无效，尝试访问该页会导致异常。

**R (Read)**：为 1 时，表示该页是可读的。如果为 0，则尝试读取该页会导致异常

**W (Write)**：为 1 时，表示该页是可写的。如果为 0，则尝试写入该页会导致异常。

**X (Execute)**：为 1 时，表示该页包含可执行代码。如果为 0，则尝试执行该页的指令会导致异常。

**U (User/Supervisor)**：为 1 时，表示该页在用户模式（非特权模式）下可访问。如果为 0，则只能在超级用户（特权模式）下访问。

**A (Accessed)**：为 1 时，表示自上次清除该位以来，该页已经被访问过。这个位可以用于页面置换算法，比如 LRU（最近最少使用）。

**D (Dirty)**：为 1 时，表示自上次将该页写回磁盘以来，该页已经被写过。在页置换时，如果 D 位为 1，则需要先将该页写回磁盘。





### 缺页

缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

（1）请问哪些异常可能是缺页导致的？

- **访问未加载页面**：访问尚未加载到内存中的页面。

- **访问无效页面**：页面表项标记为无效，进程尝试访问该页面。

- **访问被保护页面**：以不允许的权限（如写入）访问受保护的页面。



（2）发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。

- **satp 寄存器：**它用于存储页表的基址和当前的地址转换模式。当发生缺页异常时，处理器需要读取 satp 寄存器来确定当前使用的页表基址。

- **sptbr 寄存器：**它也用于存储页表的基址。在一些 RISC-V 实现中，可能使用 sptbr 寄存器来存储页表基址。

- **scause 寄存器：**用于存储导致异常的原因，包括是否是缺页异常。处理器在发生异常时会将异常原因存储在 scause 寄存器中。

- **stval 寄存器：**用于存储导致异常的具体值，比如缺页异常时，会把导致缺页的虚拟地址存储在 stval 寄存器中。



缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

（3）这样做有哪些好处？

- **提高内存利用率**：当进程真正访问某个页面时，才将其装入内存，避免不必要的内存占用。

- **启动速度更快**：程序启动时不需要加载所有页面，从而减少初始加载时间。

- **延迟加载的灵活性**：程序可以在运行过程中根据实际需要动态调整内存使用，提高运行时效率。



其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

（4）处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

**页面大小为4KB，那么总页面数=10G / 4KB = 2,621,440个页面。**

**页表大小≈2,621,440/511*8字节≈20MB**



（5）请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

- 在进程请求内存时，仅更新页表，将相应的页面标记为未加载。只有当进程首次访问该页面时，才触发实际的加载操作。

- 当缺页异常发生时，操作系统捕获异常并检查页表。如果页面未加载，OS会从磁盘中读取相应的页面，更新页表，将其标记为有效，然后重新执行导致缺页的指令。



缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

（6）此时页面失效如何表现在页表项(PTE)上？

**可以将页表项的V 位改为 0 。**





### 双页表与单页表

为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )

（1）在单页表情况下，如何更换页表？

**保存当前页表状态**：在需要切换页表之前，先保存当前页表的状态，确保在切换后可以恢复。

**更新页表基址寄存器**：操作系统会修改页表基址寄存器（如RISC-V的`satp`寄存器），将其指向新的页表的物理地址。

**清除TLB**：为了确保新的页表映射生效，通常会清除TLB中的条目，防止使用旧的地址映射。

**切换特权级别**：将CPU切换到内核模式，从而可以访问相应的内核地址空间。

**恢复和执行**：完成页表切换后，操作系统会恢复线程的状态，继续执行相应的进程。



（2）单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

**将页表项 U 标志位置为 0。**



（3）单页表有何优势？（回答合理即可）

**简化设计**：只需维护一张页表，减少了管理复杂性，降低了内存和计算开销。

**更快的地址转换**：因为只有一张页表，地址转换过程中的查找和更新相对较快。

**易于实现**：操作系统的实现相对简单，因为不需要处理多张页表之间的切换和管理。

**节省内存**：只需要存储一张页表，减少了内存的占用。

**上下文切换效率高**：切换用户线程和内核线程时，可以更快地切换上下文，因为不需要在不同的页表之间切换。



（4）双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

**双页表：**

- **当用户线程需要进行系统调用或处理异常时，操作系统需要切换到内核态，此时应更换到内核页表以保护内核空间。**
- **当操作系统切换到另一个进程或线程时，需要更新页表，以确保新进程访问正确的内存映射。**

**单页表：**

- **在进行系统调用时，立即切换到适用于内核的页表，以保护内核空间。**

- **在上下文切换时，及时更新页表，以确保新的进程能够访问其专属内存。**



## 荣誉准则

1. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

2. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。